---
title: Domina las Mutaciones en React Query
seoTitle: 'Mutaciones: Efectos Secundarios, Invalidaciones y Actualizaci√≥n Optimista'
description: Aprende todo lo necesario sobre ejecutar efectos secundarios en el servidor con las mutaciones de React Query
date: 2023-02-27
status: published
original:
  title: Mastering Mutations in React Query
  url: https://tkdodo.eu/blog/mastering-mutations-in-react-query
series:
  name: react-query-tkdodo
  index: 12
---

<script>
  import Box from '$lib/components/Box.svelte';
</script>

Hemos cubierto ya mucho terreno en lo que se refiere a las caracter√≠sicas y conceptos que ofrece React Query. La mayor√≠a es sobre la *obtenci√≥n* de data, usando el hook `useQuery`. Existe, aun as√≠, una segunda parte integral al trabajar con data: la *actualizaci√≥n*.

Para este caso, React Query expone el hook `useMutation`.

## ¬øQu√© son las mutaciones?

Hablando en general, las mutaciones son funciones que tienen un *efecto secundario*. Por ejemplo, mira el m√©tido `push` de un Array: tiene el efecto secundario de **cambiar** el array al que est√°s a√±adiendo un valor:

```js
const myArray = [1];
myArray.push(2);

console.log(myArray); // [1, 2]
```

El opuesto, **inmutable**, ser√≠a `concat`, que tambi√©n puede a√±adir valores a arrays, pero devolver√° el nuevo array, en lugar de manipular directamente el array original con el que trabajabas:

```ts
const myArray = [1];
const newArray = myArray.concat(2);

console.log(myArray); //  [1]
console.log(newArray); // [1, 2]
```

Como su nombre indica, `useMutation` tambi√©n tiene una especie de efecto secundario. Como estamos en el contexto de la [gesti√≥n de estado del servidor](/react-query/react-query-gestor-estado/) con React Query, las mutaciones describen una funci√≥n que realiza un efecto secundario **en el servidor**. Crear un nuevo `to-do` en tu base de datos ser√≠a una mutaci√≥n. Loguear a un usuario ser√≠a tambi√©n una mutaci√≥n cl√°sica, porque realiza el efecto secundario de crear un token para el usuario.

En algunos (pocos) aspectos, `useMutation` es similar a `useQuery`. En otros, muy diferente.

## Similitudes con `useQuery`

`useMutation` sigue el estado de una mutaci√≥n, igual que `useQuery` hace para las solicitudes. Te dar√° valores `loading`, `error` y `status` para hacerte m√°s sencillo mostrar a los usuarios qu√© est√° pasando.

...Y aqu√≠ acaban los parecidos: hasta React Query v4 (incluido) exist√≠an las callbacks `onSuccess`, `onError` y `onSettled` en ambos hooks, pero [esto ya no es as√≠](https://tkdodo.eu/blog/breaking-react-querys-api-on-purpose).

## Diferencias con `useQuery`

<Box>

- `useQuery` es **declarativo**.
- `useMutation` es **imperativo**.

</Box>

Eso significa que las solicitudes se ejecutan autom√°ticamente. Defines las dependencias, pero React Query se encarga de ejecutar la solicitud inmediatamente, y tambi√©n hace algunas actualizaciones en el *background* cuando lo estima necesario. Esto funciona muy bien para las solicitudes porque queremos mantener sincronizado lo que vemos en la pantalla con la data real en el backend.

Para las mutaciones, esto no funcionar√≠a tan bien. Imagina que se creara un nuevo *to-do* cada vez que enfocas la ventana de tu navegador... As√≠ que en lugar de ejecutar la mutaci√≥n inmediatamente, React Query te da una funci√≥n que puedes invocar cuando quieras hacer la mutaci√≥n:

```tsx
function AddComment({ id }) {
  // esto no hace nada todav√≠a
  const addComment = useMutation({
    mutationFn: (newComment) =>
      axios.post(`/posts/${id}/comments`, newComment),
  })

  return (
    <form
      onSubmit={(event) => {
        event.preventDefault()
        // üü¢ mutaci√≥n invocada cuando se env√≠a el form
        addComment.mutate(
          new FormData(event.currentTarget).get('comment')
        )
      }}
    >
      <textarea name="comment" />
      <button type="submit">Comment</button>
    </form>
  )
}
```

Otra diferencia es que las mutaciones no comparten estado como hace `useQuery`. Puedes llamar a `useQuery` varias veces en componentes distintos y obtendr√°s siempre el mismo resultado desde cach√©. Pero esto no funcionar√° para las mutaciones.

<Box type="updated">

- **Actualizaci√≥n**: Empezando con la v5, puedes usar el hook [`useMutationState`](https://tanstack.com/query/v5/docs/react/reference/useMutationState) para compartir estado de mutaci√≥n entre componentes.

</Box>

## Enlazando mutaciones con solicitudes

Las mutaciones, por dise√±o, no est√°n emparejadas directamente con solicitudes. Una mutaci√≥n que da un *like* a un art√≠culo en un blog no tiene ning√∫n enlace con la solicitud que obtiene ese art√≠culo. Para que eso funcione necesitar√≠as alg√∫n tipo de esquema interno, algo que React Query no tiene.

Para que el efecto de una mutaci√≥n se refleje en nuestras solicitudes, React Query ofrece dos sistemas:

### Invalidaci√≥n

Esta es conceptualmente la manera m√°s sencilla de mantener tu *pantalla* actualizada. Recuerda que solo estamos mostrando una *captura* de la data del servidor en un instante concreto. React Query intenta mantenerse al d√≠a, por supuesto, pero si cambias el estado del servidor intencionalmente con una mutaci√≥n, este es el momento ideal para avisarle de que alguna data en cach√© es ahora **inv√°lida**.

React Query entonces ir√° y har√° una re-solicitud de esa data si est√° en uso actualmente, y tu pantalla se actualizar√° autom√°ticamente cuando la solictud termine. Lo **√∫nico** que tienes que hacer es decirle a la librer√≠a qu√© solicitudes invalidar:

```tsx
const useAddComment = (id) => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (newComment) =>
      axios.post(`/posts/${id}/comments`, newComment),
    onSuccess: () => {
      // üü¢ re-solicitar los comentarios del post
      queryClient.invalidateQueries({
        queryKey: ['posts', id, 'comments']
      })
    },
  })
}
```

La invalidaci√≥n de solicitud es bastante inteligente. Como todos los [filtros de solicitudes](https://react-query.tanstack.com/guides/filters#query-filters), usa b√∫squeda aproximada (fuzzy) en la `queryKey` de la solicitud. Si tienes m√∫ltiples keys para tu lista de comentarios, se invalidar√°n todas. Eso s√≠, solo se re-solicitar√°n las que est√©n actualmente actvas. El resto se marcar√° como obsoleta (stale), lo que causar√° su re-solicitud la pr√≥xima vez que se usen.

Como ejemplo, imagina que tenemos la opci√≥n de ordenar los comentarios, y cuando se a√±adi√≥ el nuevo comentario, ten√≠amos dos solicitudes en nuestro cach√©:

```sh
['posts', 5, 'comments', { sortBy: ['date', 'asc'] }
['posts', 5, 'comments', { sortBy: ['author', 'desc'] }
```

Como solo estamos mostrando una de ellas en pantalla, `invalidateQueries` re-solicitar√° esa y marcar√° la otra como "obsoleta".

### Actualizaciones directas

Algunas veces preferimos no re-solicitar data, especialmente si la mutaci√≥n ya devuelve todo lo que neceistas. Si tienes una mutaci√≥n que actualiza el t√≠tulo de un art√≠culo, y el backend devuelve el art√≠culo completo como respuesta, puedes actualizar el cach√© directamente con `setQueryData`:

```ts
const useUpdateTitle = (id) => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (newTitle) =>
      axios
        .patch(`/posts/${id}`, { title: newTitle })
        .then((response) => response.data),
    // la respuesta se pasa a onSuccess
    onSuccess: (newPost) => {
      // üü¢ actualizar la vista detalle directamente
      queryClient.setQueryData(['posts', id], newPost)
    },
  })
}
```

Poner la data directamente en el cach√© con `setqueryData` actuar√° como si esta data se hubiera devuelto desde el backend, lo que significa que todos los componentes usando esa solicitud se re-renderizar√°n correctamente.

Tienes m√°s ejemplos de actualizaciones directas y la combinaci√≥n de los dos enfoques en la [parte 8, Claves eficaces](/react-query/claves-eficaces-react-query/).

---

El autor recomienda usar invalidaci√≥n en la mayor√≠a de casos. Por supuesto esto depende del caso de uso, pero para que las actualizaciones directas funcionen bien, necesitas m√°s c√≥digo en el frontend, y hasta cierto punto **l√≥gica duplicada** desde el backend. Las listas ordenadas son, por ejemplo, bastante dif√≠ciles de ordenar directamente, ya que la posici√≥n de una entrada podr√≠a haber cambiado tras la actualizaci√≥n. Invalidar la lista completa es un enfoque m√°s *seguro*.

## Actualizaciones optimistas

Las actualizaciones optimistas son uno de los puntos fuertes para usar las mutaciones de React Query. El cach√© de `useQurey` nos da data al instante al cambiar entre solicitudes, especialmente combinado con [prefetching](https://react-query.tanstack.com/guides/prefetching). Toda la UI parece muy r√°pida por ello, as√≠ que ¬øpor qu√© no tener las mismas ventajas para las mutaciones?

La mayor parte del tiempo tenemos la seguridad de que una mutaci√≥n funcionar√°. ¬øPor qu√© deber√≠a esperar el usuario unos segundos hasta que el backend nos d√© el ok para mostrar el resultado en pantalla? La idea de las actualizaciones optimistas es *imitar* el √©xito de una mutaci√≥n incluso antes de mandarla al servidor. Cuando este nos devuelva una respuesta de √©xito, todo lo que hay que hacer es invalidar la vista para volver a ver data *real*. Si la llamada falla, devolvemos la UI al estado anterior a la mutaci√≥n.

Esto funciona muy bien para mutaciones *peque√±as* donde el usuario espera un feedback instant√°neo. No hay nada peor que tener un bot√≥n tipo *switch* que haga una solicitud, y que no se mueva hasta que esta se haya completado. Los usuarios acabar√°n clicando dos o tres veces el mismo bot√≥n, y la UI parecer√° lenta.

### ¬øEjemplos?

El autor ha decidido no mostar un ejemplo extra. [La documentaci√≥n oficial](https://react-query.tanstack.com/guides/optimistic-updates) ya cubre este tema bastante bien, y tambi√©n hay un ejemplo en codesandbox [con Typescript](https://tanstack.com/query/v4/docs/examples/react/optimistic-updates-typescript).

Tambi√©n opina que las actualizaciones optimistas se usan en *exceso*. No todas las mutaciones necesitan ser optimistas. Deber√≠as tener mucha seguridad en que realmente casi nunca falla, porque la experiencia de usuario al volver atr√°s la UI no es muy buena: Imagina un formulario en una modal que se cierra cuando lo env√≠as, o una redirecci√≥n desde una vista detalle a una vista de lista tras una actualizaci√≥n. Si se hacen de forma prematura, es dif√≠cil deshacerlas.

Adem√°s, aseg√∫rate de que el feedback instant√°neo es **realmente necesario** (como en el bot√≥n del ejemplo anterior). El c√≥digo para hacer funcionar actualizaciones optimistas no es trivial, especialemnte en comparaci√≥n con mutaciones *normales*. Cuando replicas el resultado tienes que imitar lo que har√≠a el backend, lo que puede ser tan sencillo como cambiar un booleano o a√±adir un item a un array, pero puede complicarse r√°pido:

- Si el *to-do* que a√±ades necesita una `id`, ¬øde d√≥nde la sacas?
- Si la lista que se est√° viendo est√° ordenada, ¬ømeter√°s la nueva entrada en la posici√≥n correcta?
- ¬øQu√© pasa si otro usuario ha a√±adido algo m√°s en ese intervalo? ¬øSe mover√° la entrada que hemos a√±adido a la lista cuando se haga una re-solicitud?

Todos estos casos pueden hacer peor la experiencia de usuario en algunas situaciones, donde habr√≠a valido con deshabilitar el bot√≥n y mostrar una animaci√≥n de carga mientras la mutaci√≥n est√° en marcha. Como siempre, deber√≠as elegir la herramienta corecta para cada tarea.

## Problemas habituales

Para terminar, veamos algunas cosas que es bueno recordar al trabajar con mutaciones y que no son tan obvias al principio:

### Promesas pendientes

React Query hace un `await` con las promesas que se devuelven desde la callback de una mutaci√≥n, y sucede que `invalidateQueries` devuelve una Promesa. Si quieres que tu mutaci√≥n est√© en estado `loading` mientras se actualizan las solicitudes relacionadas, tienes que devolver en tu callback el resultado de `invalidateQueries`:

```ts
{
  // üöÄ esperar√° a la invalidaci√≥n para terminar
  onSuccess: () => {
    return queryClient.invalidateQueries({
      queryKey: ['posts', id, 'comments'],
    })
  }
}

{
  // üöÄ sin mirar atr√°s: no esperar√°
  onSuccess: () => {
    queryClient.invalidateQueries({
      queryKey: ['posts', id, 'comments']
    })
  }
}
```

### `mutate` o `mutateAsync`

El hook `useMutation` devuelve dos funciones: `mutate` y `mutateAsync`. ¬øCu√°l es la diferencia, y cu√°ndo deber√≠as usar cada una?

`mutate` no devuelve nada, mientras que `mutateAsync` devuelve una Promesa que contiene el resultado de la mutaci√≥n. As√≠ que podr√≠as tener la tentanci√≥n de usar `mutateAsync` cuando necesitas acceder a la respuesta de una mutaci√≥n, pero te recomendar√≠a usar `mutate` *casi* siempre.

Siempre puedes acceder la `data` o el `error` a trav√©s de las callbacks de la mutaci√≥n, y no tienes que preocuparte de gestionar los errores: como `mutateAsync` te da control sobre la Promesa, tambi√©n tienes que capturar los errores manualmente, o puede que te salte una ["unhandled promise rejection"](https://stackoverflow.com/questions/40500490/what-is-an-unhandled-promise-rejection).

```ts
const onSubmit = () => {
  // üü¢ acceder a la respuesta desde onSuccess
  myMutation.mutate(someData, {
    onSuccess: (data) => history.push(data.url),
  })
}

const onSubmit = async () => {
  // üö® funciona, pero no se gestionan los errores
  const data = await myMutation.mutateAsync(someData)
  history.push(data.url)
}

const onSubmit = async () => {
  // üü° esto est√° bien, pero no puede ser m√°s verboso...
  try {
    const data = await myMutation.mutateAsync(someData)
    history.push(data.url)
  } catch (error) {
    // no hacer nada
  }
}
```

Gestionar los errores no es necesario con `mutate`, porque React Query captura (y descarta) el error por ti internamente. Literalmente est√° implementado con: `mutateAsync().catch(noop)` üòé.

Las √∫nicas situaciones donde es mejor usar `mutateAsync` es cuando realmente necesitas una Promesa por el hecho de que sea una promesa. Esto puede ser necesario si quieres lanzar m√∫ltiples Promesas de forma concurrente y esperar a que todas terminen, o si tienes mutaciones dependientes y no quieres caer en un "callback hell".

### Las mutaciones solo aceptan un argumento en `variables`

Como el √∫ltimo argumento de `mutate` es el objeto de opciones, `useMutation` actualmente solo acepta *un* argumento para variables. Esto es por supuesto una limitaci√≥n, pero se puede salvar f√°cilmente usando un *objeto*:

```tsx
// üî¥ sintaxis inv√°lida, NO funcionar√°
const mutation = useMutation({
  mutationFn: (title, body) => updateTodo(title, body),
})
mutation.mutate('hello', 'world')

// üü¢ usa un objeto para m√∫ltiples variables
const mutation = useMutation({
  mutationFn: ({ title, body }) => updateTodo(title, body),
})
mutation.mutate({ title: 'hello', body: 'world' })
```

Para leer m√°s sobre por qu√© esto es necesario, puedes mirar [esta discusi√≥n](https://github.com/tannerlinsley/react-query/discussions/1226).

### Algunas callbacks no se ejecutar√°n

Puedes tener callbacks tanto en `useMutation` como en la misma `mutate`. Es importante saber que las callbacks en `useMutation` se ejecutan **antes** que las de `mutate`. Adem√°s, puede que las callbacks en `mutate` no se ejecuten si el componente se desmonta antes de que la mutaci√≥n haya terminado.

Por eso pienso que es una buena pr√°ctica separar responsabilidades en tus callbacks:

- Haz las cosas que sean absolutamente necesarias y relacionadas con la l√≥gica (como invalidar solicitudes) en las callbacks de `useMutation`.
- Haz cosas relacioandas con la UI como redirecciones o mostrar notificaciones en las callbacks de `mutate`. Si el usuario se marcha de la pantalla actual antes de la que la mutaci√≥n termine, estas no se llamar√°n.

Esta separaci√≥n funciona todav√≠a mejor cuando el `useMutation` viene de un hook personalizado, ya que esto mantendr√° la l√≥gica de solicitud en el hook, mientras las acciones de UI est√°n en la UI. Esto tambi√©n hace el hook m√°s reutilizable, porque puede que la interacci√≥n con la UI var√≠e seg√∫n el caso, pero la l√≥gica de invalidaci√≥n se mantenga constante:

```ts
const useUpdateTodo = () =>
  useMutation({
    mutationFn: updateTodo,
    // üü¢ invalidar la lista siempre
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: ['todos', 'list']
      })
    },
  })

// en el componente:
const updateTodo = useUpdateTodo()
updateTodo.mutate(
  { title: 'newTitle' },
  // üü¢ solo redirigir si seguimos en la p√°gina detalle
  // cuando la mutaci√≥n termine
  { onSuccess: () => history.push('/todos') }
)
```
